\chapter*{Introduction}
	\thispagestyle{introduction}
	\addcontentsline{toc}{chapter}{Introduction}

% Introduction (5 paragraphes: contexte, problème, objectif, solution, évaluation)

%contexte
\par Il existe plusieurs méthodologies pour développer une application, dont le TDD\footnote{Développement dirigé par les tests / Test driven development}. Cette pratique préconise d'écrire en premier lieux les spécifications sous forme de tests unitaires. C'est uniquement après avoir vérifier que ces spécifications ne sont pas respectées, que le développeur va écrire le code nécessaire à les valider. Cette méthode apporte ne nombreux avantages, comme la garantie d'avoir un code testé et moins sujet à la régression, le respect de la spécification, apporte de la confiance aux développeurs lors de \textit{refactoring}. 

%probleme
\par Il est vrai que si dans la théorie, le développement dirigé par les tests ne possède que des avantages, ce n'est pas pour autant que cette technique est utilisée systématiquement dans le monde professionnel. Il est courant dans le monde professionnel de développer des applications sans aucun tests. En effet, réaliser de bons tests est un coût pour l'entreprise, et ces dernières se focalisent généralement sur le code métier dans un premier temps. Si jamais des tests sont écrits, ils le sont très souvent qu'une fois l'application terminé, ne respectant pas le principe du TDD. Une question peut alors se poser : Est-il possible de mettre au point un outil permettant aux développeurs d'écrire uniquement une spécification, pour ensuite synthétiser le code métier ?

%objectif
\par L'objectif est de montrer qu'un tel outils existe. La solution proposée ici est appelée ????, elle est grandement inspirée par un outils appelé Nopol\cite{nopol}, et plus particulièrement DynaMoth\cite{dynamoth}, la dernière version de son moteur de synthèse. Cette approche utilise les entrées / sorties des tests pour définir des contraintes, et essaye de les résoudre.


%évaluation
\par EVAL ????